/*
Abraham Ponnuraj
DA & DS Feb 2025 Batch
21-Mar-2025
Advanced SQL – Reinforcement Project – IMDB Dataset 
*/

/*
Data Base Name : imdb
No. of Table in this DB is: 6 table
*/
select * from director_mapping;
select count(*) from director_mapping;
desc director_mapping;
/*
1. director_mapping
This table has two columns 
movie_id & name_id
this two columns are foreign keys, movie_id is related to movie table and name_id is related to names table.
total records is 3867
*/
select * from genre;
select count(*) from genre;
desc genre;
/*
This table has two columns 
movie_id and genre
It describes the movie category, with movie_id serving as a reference to the movie table. Using this movie_id, 
we can determine the genre of each movie. The table contains a total of 14,662 records.
*/
select * from movie;
desc movie;
select count(*) from movie;#7997
/*
3. movie
this table contains the below 9 columns
id
title
year
date_published
duration
country
worlwide_gross_income
languages
production_company
The movie table contains 7997 records and serves as the central dataset for movie-related information. 
The id column acts as the primary key, uniquely identifying each movie. 
The title column stores the movie name, while the year and date_published columns indicate the release year and exact release date, respectively. 
The duration column represents the length of the movie in minutes. 
The country column lists the countries where the movie was released, allowing multiple values if it premiered in different locations. 
The worldwide_gross_income column captures the total revenue generated by the movie globally. 
The languages column specifies the languages in which the movie was made, accommodating multiple entries for multilingual films. 
Finally, the production_company column records the name of the company responsible for producing the movie.
*/

select * from names;
select count(*) from names;#25735
/*
names
this table contains 25735 rows
this table has 5 columns
id
name
height
date_of_birth
known_for_movies
The id column is the primary key.
The name column contains the names of actors, actresses, and directors.
The height column stores the height of actors, actresses, and directors in centimeters.
The date_of_birth column records their birth dates.
The known_for_movies column is a foreign key linking to the movie table.
*/
select * from ratings;
select count(*) from ratings;
desc ratings;
/*
ratings
this table has 4 columns
movie_id
avg_rating
total_votes and
median_rating
This table contains 7,997 records.
The movie_id column is a foreign key linking to the movie table.
The avg_rating column represents the average rating of each movie.
The total_votes column indicates the number of votes a movie has received.
The median_rating column provides the movie's median rating (out of 10) to assess its quality.
*/
select * from role_mapping;
select count(*) from role_mapping;#15615
desc role_mapping;
select distinct(category) from role_mapping;
select count(*) from role_mapping where category='actor';#9362
select count(*) from role_mapping where category='actress';#6253
/*
role_mapping
this table has 3 columns
movie_id
name_id and
category
This table contains a total of 151,615 rows, including 9,362 records for actors and 6,253 records for actresses.
*/

#Queries to be Performed 
#1. Count the total number of records in each table of the database. 
/*
To retrieve the total number of records in each table, we use the COUNT aggregate function in the SELECT statement. 
The query below is used to obtain the total record count for each table in this database.
*/
use imdb;
select count(*) total_no_movie from movie; #total_no_movie = 7997
select count(*) total_no_genre from genre; #total_no_genre = 14662
select count(*) total_no_director from director_mapping; #total_no_director = 3867
select count(*) total_no_names from names; #total_no_names = 25735
select count(*) total_no_ratings from ratings; #total_no_ratings = 7997
select count(*) total_no_role_mapping from role_mapping; #total_no_role_mapping = 15615
/*
Here are the total record counts for each table in the database:
Total number of movies: 7,997
Total number of genres: 14,662
Total number of directors: 3,867
Total number of names: 25,735
Total number of ratings: 7,997
Total number of role mappings: 15,615
*/
Delimiter $$
create procedure Total_No_Records_In_IMDB()
BEGIN
	select count(*) total_no_director from director_mapping; #total_no_director = 3867
	select count(*) total_no_genre from genre; #total_no_genre = 14662
	select count(*) total_no_movie from movie; #total_no_movie = 7997
	select count(*) total_no_names from names; #total_no_names = 25735
	select count(*) total_no_ratings from ratings; #total_no_ratings = 7997
	select count(*) total_no_role_mapping from role_mapping; #total_no_role_mapping = 15615
END $$
Delimiter ;

call Total_No_Records_In_IMDB();

#2. Identify which columns in the movie table contain null values. 
/*
To identify null values in a table, I use the IS NULL operator in the WHERE condition. In the movie table, I checked all columns and found the following null value 
counts:
country column has 20 null rows.
worldwide_gross_income column has 3,724 null rows.
languages column has 194 null rows.
production_company column has 528 null rows.
*/
desc movie;
select * from movie;
select * from movie where country is null or worlwide_gross_income is null or languages is null or production_company is null order by 
country, worlwide_gross_income, languages, production_company;
select count(*) from movie where country is null;#20 rows
select count(*) from movie where worlwide_gross_income is null;#3724 rows
select count(*) from movie where languages is null;#194 rows
select count(*) from movie where production_company is null;#528 rows

select 
sum(case when country is null then 1 else 0 end) as total_country_null_count,
sum(case when worlwide_gross_income is null then 1 else 0 end) as total_worlwide_gross_incomee_null_count,
sum(case when languages is null then 1 else 0 end) as languages_null_count,
sum(case when production_company is null then 1 else 0 end) as production_company_null_couunt
from movie;

#3. Determine the total number of movies released each year, and analyze how the trend changes month-wise. 
select year from movie group by year; #2017, 2018 & 2019
select count(*), year from movie group by year order by year;
select count(*), date_published from movie group by date_published order by date_published;
#Below query will fetch the total movies by year and month wise.
SELECT  year, 
       MONTH(date_published) AS release_month, 
       COUNT(*) AS total_movies
FROM movie
GROUP BY  year, release_month
ORDER BY  year, release_month;
#The below query will fetch the total movive count of the yeaar 2017, 2018 and 2019 and also the cumulative movie count.
SELECT YEAR release_year, 
       COUNT(*) AS total_movies,
       SUM(COUNT(*)) OVER (ORDER BY YEAR) AS cumulative_movies
FROM movie
GROUP BY year
ORDER BY year;
#using sub-query to get the total movie count of the year
SELECT 
    year, 
    MONTH(date_published) AS release_month, 
    COUNT(*) AS total_movies,
    (SELECT COUNT(*) 
     FROM movie AS m2 
     WHERE m2.year = m1.year) AS yearly_total_movies
FROM movie AS m1
GROUP BY year, release_month
ORDER BY year, release_month;
/*
This is the final query to fetch the movie count for each year with a month-wise total in a row-wise format. 
The SUM aggregate function is used to calculate the total number of movies released in each month. Additionally, 
the MONTH() function is applied to the date_published column to categorize movies based on their release month. 
Finally, the data is grouped by year to present a structured view of movie releases over time.

The dataset shows a declining trend in the number of movies released from 2017 to 2019.
The peak months for movie releases were September and October, with consistently high numbers across years.
December 2019 saw the least movie releases (only 16), possibly due to industry slowdowns or external factors.
September 2017 had the highest releases (327), suggesting it might be a peak release period.
*/
SELECT 
    year,
    sum(month(date_published) = 1) as jan,
    sum(month(date_published)=2) as feb,
    sum(month(date_published)=3) as mar,
    sum(month(date_published)=4) as apr,
    sum(month(date_published)=5) as may,
    sum(month(date_published)=6) as jun,
    sum(month(date_published)=7) as jul,
    sum(month(date_published)=8) as aug,
    sum(month(date_published)=9) as sep,
    sum(month(date_published)=10) as oct,
    sum(month(date_published)=11) as nov,
    sum(month(date_published)=12) as 'dec'
FROM movie
GROUP BY year
ORDER BY year;

/*
4. How many movies were produced in either the USA or India in the year 2019?
To retrieve movies produced in the year 2019 and released in USA or India, we need to use the WHERE condition along with the 
LIKE operator to filter records where the country column contains either USA or India.
The query below returns 1,059 movies that were released in 2019 in either USA or India.
*/
select count(*) from movie m where m.year = 2019 and (country = 'USA' or country = 'India');#887
select count(*) from movie m where year(m.date_published) = 2019 and (country like '%USA%' or country like '%India%'); #1059
select * from movie m where m.year=2019 and m.country like '%USA%' order by country asc;#758
select * from movie m where m.year=2019 and m.country like '%India%' order by country asc;#309
/*
5. List the unique genres in the dataset, and count how many movies belong exclusively to one genre. 
To get the unique genres, we need to use the DISTINCT function to retrieve unique genre types from the genre table. 
Additionally, the COUNT function is used to calculate the number of movies in each genre.
The result below shows that Drama is the most common genre, with 4,285 movies, compared to other genres.
*/
select * from genre;
select distinct(genre) from genre order by genre asc; #13 unique genre's
select distinct(genre), count(movie_id) movie_count from genre group by genre order by movie_count desc;
/*
6. Which genre has the highest total number of movies produced? 
In the previous query, we retrieved the total number of movies for each genre. To determine the genre with the highest number of movies, 
we need to sort the movie count in descending order using the ORDER BY clause. Additionally, we use the LIMIT clause to restrict the result to only the top row.
The query returns Drama as the genre with the highest number of movies, totaling 4,285.
*/
select distinct(genre), count(*) movie_count from genre group by genre order by movie_count desc limit 1;

/*
7. Calculate the average movie duration for each genre. 
The query calculates the average duration of movies for each genre by joining the movie and genre tables using the movie_id column. 
It uses the AVG() function to compute the average duration and groups the results by genre. The results are sorted in ascending order of genre names.
Action movies have the highest average duration (112.88 minutes), making them one of the longest genres.
Romance movies also tend to be long, with an average duration of 109.53 minutes.
Horror movies have the shortest average duration (92.72 minutes), suggesting they are typically more concise.
Most other genres, including Comedy, Crime, Drama, and Thriller, fall within the 100-110 minute range.
This analysis helps in understanding the general length of movies based on their genre, which can be useful for filmmakers, 
streaming platforms, and audiences when selecting movies.
*/
select * from genre;
select * from movie;
select g.genre, avg(duration) as avg_duration from movie m inner join genre g on g.movie_id = m.id 
group by g.genre order by g.genre asc;

/*
8. Identify actors or actresses who have appeared in more than three movies with an average 
rating below 5.
The query attempts to identify actors or actresses who have appeared in more than three movies where the average rating is below 5.
No actors or actresses have appeared in more than three movies where the average rating is below 5.
This suggests that actors generally do not consistently work on poorly rated films or that the dataset does not have such cases.
This insight helps in analyzing actor performance trends and movie quality associations.
*/
select * from names;
select name, count(known_for_movies) moviecnt from names group by name order by moviecnt desc;
select * from movie;
select * from ratings r where r.avg_rating < 5 order by r.avg_rating desc;
SELECT n.name AS actor_name, COUNT(m.id) AS num_movies, avg(r.avg_rating) avg_rating
FROM movie m
inner join names n on n.known_for_movies = m.id
inner join ratings r on r.movie_id = n.known_for_movies
WHERE r.avg_rating < 5
GROUP BY m.id, n.name
HAVING COUNT(m.id) > 3
ORDER BY num_movies DESC;


select * from ratings;
/*
9. Find the minimum and maximum values for each column in the ratings table, excluding the 
movie_id column. 
The query retrieves the minimum and maximum values for each numeric column in the ratings table, excluding the movie_id column.
min(avg_rating), max(avg_rating):
Finds the lowest and highest average movie ratings.
min(total_votes), max(total_votes):
Identifies the least and most number of votes received by any movie.
min(median_rating), max(median_rating):
Determines the minimum and maximum median ratings.


Some movies received the lowest possible rating (1.0), while others achieved a perfect score (10.0).
The total votes range from 100 (minimum engagement) to 725,138 (highly rated/popular movies).
The median rating distribution also spans from 1 to 10, indicating a diverse mix of critically poor and highly acclaimed films.
This analysis helps in understanding movie popularity trends and rating distributions across the dataset.
*/ 
select 
	min(avg_rating) min_avg_rating, max(avg_rating) max_avg_rating, 
	min(total_votes) min_total_votes, max(total_votes) max_total_votes, 
	min(median_rating) min_median_rating, max(median_rating) max_median_rating
from ratings;

/*
10. Which are the top 10 movies based on their average rating? 
This analysis helps in identifying highly acclaimed movies based on viewer ratings.
The query retrieves the top 10 movies sorted by their average rating in descending order.
Retrieves movie details (id, title, date_published).
Joins the movie table with the ratings table using movie_id.
Orders the results based on avg_rating in descending order.
Limits the output to 10 movies (highest-rated).

Two movies ("Kirket" and "Love in Kilnerry") received perfect ratings (10.0).
Most top-rated movies were released in 2019, indicating strong audience engagement that year.
The Indian movie "Android Kunjappan Version 5.25" (Malayalam) made it to the top with 9.6 rating.
*/
select * from movie;
select * from ratings order by avg_rating desc;

select 
	m.id, 
    m.title, 
    m.date_published,
    r.avg_rating 
from 
	movie m 
inner join ratings r 
on m.id = r.movie_id 
order by r.avg_rating desc limit 10;

/*
11. Summarize the ratings table by grouping movies based on their median ratings. 
High-rated movies (9-10) are fewer in number but generally have higher votes per movie.
Most movies cluster around the 6-7 range, showing that the majority are perceived as average or slightly above average.
Lower-rated movies (1-3) exist but are relatively fewer, suggesting that truly bad movies are rare or receive fewer votes.
*/
select * from ratings;
select 
	median_rating as Median_Rating, 
    count(movie_id) Total_Movie, 
    avg(avg_rating) Avg_Rating, 
    sum(total_votes) Sum_of_Votes
from 
	ratings 
group by median_rating 
order by median_rating desc;
/*
12. How many movies, released in March 2017 in the USA within a specific genre, had more 
than 1,000 votes? 
A total of 40 movies were released in March 2017 in the USA.

In the movie table, we only have the date_published column. Therefore, we used the MONTH() function to filter movies released in March 
and the YEAR() function to filter those from 2017.
Since the country column contains multiple values (e.g., South Africa, USA, Germany), we used the LIKE operator to fetch movies 
that include 'USA' as one of the countries.
*/
select  * from movie;
select * from ratings;
select * from genre;

select 
	m.id, m.title, m.duration, m.country, r.avg_rating, r.total_votes, r.median_rating, 
   GROUP_CONCAT(DISTINCT g.genre ORDER BY g.genre ASC) AS genres 
from 
	movie m 
inner join ratings r on m.id = r.movie_id 
inner join genre g on g.movie_id = r.movie_id
where 
	month(m.date_published) = 3 and year(m.date_published)=2017 and m.country like '%USA%' and r.total_votes > 1000
group by m.id, m.title, m.duration, m.country, r.avg_rating, r.total_votes, r.median_rating
order by r.total_votes asc, m.title asc; #40 movies that are realised in Mar 2017 in USA with more than 1000 votes.

/*
13. Find movies from each genre that begin with the word “The” and have an average rating 
greater than 8. 
Using the LIKE operator in the WHERE clause, we filtered genres that begin with the word 'The' and have an average rating above 8.
A total of 15 genres meet these criteria.
*/
select * from movie;
select * from genre;

select 
	m.id, m.title, m.duration, m.country, r.avg_rating, r.total_votes, r.median_rating, g.genre
from movie m 
inner join ratings r on m.id = r.movie_id 
inner join genre g on g.movie_id = r.movie_id
where m.title like 'The%' and r.avg_rating > 8
order by r.avg_rating desc, m.title asc;

/*
14. Of the movies released between April 1, 2018, and April 1, 2019, how many received a 
median rating of 8? 
A total of 361 movies were released between 1st April 2018 and 1st April 2019 and received a median rating of 8.
To achieve this, the BETWEEN keyword was used to filter movies within the specified date range (1st April 2018 to 1st April 2019) and with a median_rating of 8.
*/
select * from movie;
select * from ratings;
select 
	m.id, m.title, m.date_published, m.duration, m.country, r.avg_rating, r.total_votes, r.median_rating
from movie m inner join ratings r on m.id = r.movie_id
where m.date_published between '2018-04-01' and '2019-04-01' and r.median_rating = 8
order by m.date_published asc;
/*
15. Do German movies receive more votes on average than Italian movies? 
German movies receive more votes on average (730.89 votes per movie) than Italian movies (633.86 votes per movie).
Both countries have similar average ratings (Germany: 5.96, Italy: 5.94), indicating no significant difference in viewer ratings.
*/
select * from movie;
select  m.country, count(m.id) movie_count,avg(r.avg_rating) avg_rating,  sum(r.total_votes), avg(r.total_votes) as avg_total_votes_per_movie
from movie m inner join ratings r on m.id = r.movie_id where m.country in('Germany', 'Italy')
group by m.country order by m.country;

select  
CASE 
        WHEN m.country LIKE '%Germany%' THEN 'Germany'
        WHEN m.country LIKE '%Italy%' THEN 'Italy'
    END AS Country,
count(m.id) movie_count,avg(r.avg_rating) avg_rating,  sum(r.total_votes) total_votes, avg(r.total_votes) as avg_total_votes_per_movie
from movie m inner join ratings r on m.id = r.movie_id where m.country like '%Germany%' or m.country like '%Italy%'
group by m.country  order by m.country;
/*
16. Identify the columns in the names table that contain null values. 
In the names table, there are five columns: id, name, height, date_of_birth, and known_for_movies.
The id and name columns do not contain any NULL values.
The remaining columns contain NULL values as follows:
height → 17,335 NULL values
date_of_birth → 13,431 NULL values
known_for_movies → 15,226 NULL values
*/
SELECT 
    SUM(CASE WHEN id IS NULL THEN 1 ELSE 0 END) AS null_id_count,
    SUM(CASE WHEN name IS NULL THEN 1 ELSE 0 END) AS null_name_count,
    SUM(CASE WHEN height IS NULL THEN 1 ELSE 0 END) AS null_height_count,
    SUM(CASE WHEN date_of_birth IS NULL THEN 1 ELSE 0 END) AS null_dob_count,
    SUM(CASE WHEN known_for_movies IS NULL THEN 1 ELSE 0 END) AS null_known_for_movies_count
FROM names;

/*
17. Who are the top two actors whose movies have a median rating of 8 or higher? 
To get the top two actors with a median rating above 8, we need to join the names, role_mapping, movie, and ratings tables.

The result shows that actor Mammootty has 8 movies with a median rating of 8 or higher, while Mohanlal has 5 such movies.
*/
select * from role_mapping;
select * from names;
select * from ratings;
SELECT n.name, COUNT(m.id) AS movie_count
FROM names n
JOIN role_mapping rm ON n.id = rm.name_id
JOIN movie m ON rm.movie_id = m.id
JOIN ratings rt ON m.id = rt.movie_id
WHERE rm.category = 'actor' AND rt.median_rating >= 8
GROUP BY n.name
ORDER BY movie_count DESC
LIMIT 2;

select n.name, count(m.id) numberofmovies, r.median_rating
from names n 
inner join role_mapping rm on rm.name_id = n.id
inner join movie m on m.id = rm.movie_id
inner join ratings r on r.movie_id=m.id 
where rm.category = 'actor' and r.median_rating >=8
group by n.name, r.median_rating order by numberofmovies desc, median_rating desc;#8248

/*
18. Which are the top three production companies based on the total number of votes their 
movies received? 
Marvel Studios got the highest votes (2.65M) with just 5 movies.
Twentieth Century Fox (12 movies) and Warner Bros. (19 movies) had fewer votes per movie.
Marvel movies attract more audience engagement per film.
*/
select * from movie;
select * from ratings;
select m.production_company, count(m.id) as movie_count, sum(r.total_votes) as total_votes 
from movie m inner join ratings r on r.movie_id = m.id
where m.production_company is not null
group by m.production_company order by total_votes desc limit 3;

/*
19. How many directors have worked on more than three movies? 
Three directors have worked on more than three movies.
A.L. Vijay directed the most (5 movies).
Özgür Bakar and Sam Liu each directed 4 movies.
These directors are consistently involved in multiple projects.
*/
select * from director_mapping;
select * from names;
select count(m.id) movie_count, n.name from names n inner join director_mapping d on d.name_id = n.id inner join movie m on m.id=n.known_for_movies
where n.known_for_movies is not null group by n.name having count(m.id) > 3 order by movie_count desc;

/*
20. Calculate the average height of actors and actresses separately. 
The average height of actors is 162.18 cm.
The average height of actresses is 162.47 cm.
There is only a 0.29 cm difference, meaning actors and actresses have nearly the same average height.
*/
select * from names;
select * from role_mapping;
select name, avg(height) as avg_height from names where height is not null group by name order by name asc;
SELECT 
    rm.category, 
    AVG(n.height) AS avg_height
FROM names n
JOIN role_mapping rm ON rm.name_id = n.id
WHERE n.height IS NOT NULL 
AND rm.category IN ('Actor', 'Actress')
GROUP BY rm.category
ORDER BY rm.category;
/*
21. List the 10 oldest movies in the dataset along with their title, country, and director. 
All 10 oldest movies in the dataset were released on January 1, 2017.
The movies come from different countries, including USA, Canada, UK, and Italy.
USA has the most movies on the list, followed by Canada.
*/
select * from director_mapping;
select * from names;
select * from movie where date_published is null;
select * from names where known_for_movies is not null;
select 
	m.id, m.title, m.date_published, m.country,
    n.name
from movie m 
inner join director_mapping d on d.movie_id = m.id
inner join names n on n.id = d.name_id
order by date_published asc limit 10;

/*
22. List the top 5 movies with the highest total votes, along with their genres. 
To fetch the top 5 movies with the highest total votes along with their genres, we need to join the movie table with ratings and genre tables.
Since the genre table contains multiple genre values for each movie, we use the GROUP_CONCAT aggregate function to concatenate 
multiple genre values into a single string.
We group the results by movie ID, title, and total votes, then order them by total votes in descending order and use LIMIT to fetch the top 5 rows.
The most common genres among these movies are Action, Adventure, and Sci-Fi, with some featuring Drama or Comedy.
Avengers: Infinity War received the highest number of total votes (725,138), followed by Avengers: Endgame (602,792).

*/
select * from movie;
select * from ratings;
select * from genre;

select m.id,m.title,r.total_votes,
GROUP_CONCAT(DISTINCT g.genre ORDER BY g.genre ASC) AS genres 
from movie m inner join ratings r on m.id = r.movie_id
inner join genre g on g.movie_id = r.movie_id
group by m.id,m.title,r.total_votes
order by r.total_votes desc limit 5;

/*
23. Identify the movie with the longest duration, along with its genre and production company. 
To identify the movie with the longest duration, along with its genre and production company, we can use two approaches:
Sorting the duration in descending order and selecting the top row using LIMIT 1.
Using a WHERE condition to filter the movie with the maximum duration.
*/
select m.title, m.duration, m.production_company, 
GROUP_CONCAT(DISTINCT g.genre ORDER BY g.genre ASC) AS genres 
from movie m inner join genre g on g.movie_id = m.id 
group by m.title,m.duration,m.production_company
order by m.duration desc limit 1;

SELECT 
    m.title, 
    m.duration, 
    m.production_company, 
    GROUP_CONCAT(DISTINCT g.genre ORDER BY g.genre ASC SEPARATOR ', ') AS genres 
FROM movie m 
JOIN genre g ON g.movie_id = m.id 
WHERE m.duration = (SELECT MAX(duration) FROM movie) 
GROUP BY m.title, m.duration, m.production_company;
/*
24. Determine the total number of votes for each movie released in 2018.
To get the total number of movies released in 2018 along with their total votes, we need to join the movie table with ratings, 
filter for movies released in 2018, and group the data by movie_id, title, and date_published to calculate the total votes for each movie.
*/
select 
	m.id, m.title, sum(r.total_votes) as total_votes, m.date_published 
from 
	movie m  
    inner join ratings r on r.movie_id = m.id 
where 
	year(m.date_published) = 2018
group by 
	m.id, m.title, m.date_published 
order by m.date_published;

/*
25. What is the most common language in which movies were produced? 
select * from movie m;
in movie table there is one column languages which contains values like the below
English, French, Russian
To determine the most common language in which movies were produced, we need to analyze the languages column in the movie table. 
Since this column may contain multiple languages in a single row (e.g., "English, French, Russian"), we should split these values 
and count each language separately.

The most common language for movie production is English, with 4,134 movies. This is followed by French (612), Spanish (566), Hindi (341), and German (335).

To determine the most common language:
We split the languages column into individual languages and stored them in a temporary table (temp_movie_languages).
Then, we counted the number of movies produced in each language.
The result was sorted in descending order to find the most frequently used language.
*/
select distinct (languages) from movie m;

-- Drop temp table if it already exists
DROP TEMPORARY TABLE IF EXISTS temp_movie_languages;

-- Create a temporary table to store results
CREATE TEMPORARY TABLE temp_movie_languages (
    movie_id varchar(100),
    title VARCHAR(255),
    language VARCHAR(100)
);

-- Declare variables
DELIMITER $$

CREATE PROCEDURE SplitLanguages()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE movieID varchar(100);
    DECLARE movieTitle VARCHAR(255);
    DECLARE langList VARCHAR(255);
    DECLARE singleLang VARCHAR(100);
    
    -- Declare cursor to fetch movie data
    DECLARE movie_cursor CURSOR FOR 
        SELECT id, title, languages FROM movie;
    
    -- Declare a handler for cursor completion
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    -- Open cursor
    OPEN movie_cursor;
    
    read_loop: LOOP
        -- Fetch movie data
        FETCH movie_cursor INTO movieID, movieTitle, langList;
        IF done THEN
            LEAVE read_loop;
        END IF;

        -- Loop through each language using WHILE loop
        WHILE LENGTH(langList) > 0 DO
            SET singleLang = TRIM(SUBSTRING_INDEX(langList, ',', 1));  -- Get first language
            SET langList = IF(INSTR(langList, ',') > 0, TRIM(SUBSTRING(langList, INSTR(langList, ',') + 1)), ''); -- Remove first language from the list
            
            -- Insert into temp table
            INSERT INTO temp_movie_languages (movie_id, title, language)
            VALUES (movieID, movieTitle, singleLang);
        END WHILE;
    END LOOP;
    
    -- Close cursor
    CLOSE movie_cursor;
END $$

DELIMITER ;

-- Call the procedure to populate the temp table
CALL SplitLanguages();

-- Retrieve the results
SELECT language, movie_id, title FROM temp_movie_languages order by language asc;
select distinct(language) most_common_language, count(movie_id) movie_count from temp_movie_languages 
group by most_common_language order by movie_count desc;

SELECT lang AS language, COUNT(*) AS count
FROM (
    SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(m.languages, ', ', n.n), ', ', -1) AS lang
    FROM movie m
    JOIN (
        SELECT 1 AS n UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL 
        SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL 
        SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9 UNION ALL SELECT 10
    ) n 
    ON CHAR_LENGTH(m.languages) - CHAR_LENGTH(REPLACE(m.languages, ', ', '')) >= n.n - 1
) sub
GROUP BY lang
ORDER BY count DESC
LIMIT 1;